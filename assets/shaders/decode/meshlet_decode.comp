#version 450

#extension GL_EXT_scalar_block_layout : require
#include "../inc/meshlet_payload_constants.h"
#extension GL_KHR_shader_subgroup_basic : require

layout(local_size_x = MESHLET_PAYLOAD_MAX_THREADS) in;

layout(constant_id = 0) const uint NUM_U32_STREAMS = MESHLET_PAYLOAD_MAX_STREAMS;
layout(constant_id = 1) const bool UNROLLED_MESH = false;
layout(constant_id = 2) const uint TARGET_MESH_STYLE = 0;
layout(constant_id = 3) const bool RUNTIME_MESH = false;

#define MESHLET_PAYLOAD_DESCRIPTOR_SET 0
#define MESHLET_PAYLOAD_META_BINDING 0
#define MESHLET_PAYLOAD_STREAM_BINDING 1
#define MESHLET_PAYLOAD_PAYLOAD_BINDING 2
#include "../inc/meshlet_payload_decode.h"
#include "../inc/meshlet_attribute_decode.h"
#include "../inc/meshlet_payload_constants.h"

const int MESH_STYLE_WIREFRAME = 0;
const int MESH_STYLE_TEXTURED = 1;
const int MESH_STYLE_SKINNED = 2;

layout(set = 0, binding = 3, scalar) writeonly buffer OutputIndices
{
    uvec3 data[];
} output_indices32;

layout(set = 0, binding = 3, scalar) writeonly buffer OutputIndices8
{
    u8vec3 data[];
} output_indices8;

layout(set = 0, binding = 4, scalar) writeonly buffer OutputStreamPos
{
    vec3 data[];
} output_stream_pos;

struct TexturedAttr
{
    uint normal;
    uint tangent;
    vec2 uv;
};

layout(set = 0, binding = 5, std430) writeonly buffer OutputStreamTextured
{
    TexturedAttr data[];
} output_stream_textured_attr;

layout(set = 0, binding = 6, std430) writeonly buffer OutputStreamSkin
{
    uvec2 data[];
} output_stream_skin;

layout(set = 0, binding = 7, std430) readonly buffer OutputOffsets
{
    uint data[];
} primitive_output_offsets;

struct IndirectDrawMesh
{
    uint primitive_offset;
    uint vertex_offset;
};

layout(set = 0, binding = 8, std430) writeonly buffer IndirectCommandsMesh
{
    IndirectDrawMesh draws[];
} indirect_commands_mesh;

struct IndirectIndexedDraw
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

layout(set = 0, binding = 8, std430) writeonly buffer IndirectCommandsMDI
{
    IndirectIndexedDraw draws[];
} indirect_commands_mdi;

layout(push_constant, std430) uniform Registers
{
    uint primitive_offset;
    uint vertex_offset;
    uint meshlet_offset;
} registers;

uint pack_a2bgr10(vec4 v)
{
    ivec4 quantized = ivec4(round(clamp(v, vec4(-1.0), vec4(1.0)) * vec4(511.0, 511.0, 511.0, 1.0))) & ivec4(1023, 1023, 1023, 3);
    return (quantized.a << 30) | (quantized.b << 20) | (quantized.g << 10) | (quantized.r << 0);
}

void main()
{
    uint meshlet_index = gl_WorkGroupID.x;
    MeshletMetaRaw meta = meshlet_metas_raw.data[meshlet_index];

    int lane_index;
    uint chunk_index;
    uint linear_index;

    if (gl_SubgroupSize == 64)
    {
        chunk_index = gl_SubgroupID;
        lane_index = int(gl_SubgroupInvocationID);
        linear_index = chunk_index * 64u + lane_index;
    }
    else if (gl_SubgroupSize == 32)
    {
        chunk_index = gl_SubgroupID / 2u;
        lane_index = int(gl_SubgroupInvocationID) + int(gl_SubgroupID & 1) * 32;
        linear_index = gl_SubgroupID * gl_SubgroupSize + gl_SubgroupInvocationID;
    }
    else
    {
        linear_index = gl_LocalInvocationIndex;
        chunk_index = linear_index / 64u;
        lane_index = int(linear_index & 63u);
    }

    uint primitive_output_offset = primitive_output_offsets.data[meshlet_index] + registers.primitive_offset;

    if (!UNROLLED_MESH && gl_LocalInvocationIndex == 0)
    {
        MeshletInfo info = meshlet_get_meshlet_info(meshlet_index * NUM_U32_STREAMS);

        if (RUNTIME_MESH)
        {
            IndirectDrawMesh draw;
            draw.primitive_offset = primitive_output_offset;
            // Unrolled. Always allocate full entries.
            draw.vertex_offset = gl_WorkGroupSize.x * meshlet_index + registers.vertex_offset;
            indirect_commands_mesh.draws[meshlet_index + registers.meshlet_offset] = draw;
        }
        else
        {
            IndirectIndexedDraw draw;
            draw.indexCount = 3 * info.primitive_count;
            draw.instanceCount = 1;
            draw.vertexOffset = meta.base_vertex_offset + registers.vertex_offset;
            draw.firstIndex = 3 * primitive_output_offset;
            draw.firstInstance = 0;
            indirect_commands_mdi.draws[meshlet_index + registers.meshlet_offset] = draw;
        }
    }

    MeshletChunkInfo chunk_info = meshlet_get_chunk_info(meshlet_index * NUM_U32_STREAMS, chunk_index);

    // Index
    if (chunk_index < meta.num_chunks && lane_index < chunk_info.primitive_count)
    {
        uvec3 indices = meshlet_decode_index_buffer(
                meshlet_index * NUM_U32_STREAMS + MESHLET_STREAM_TYPE_PRIMITIVE,
                chunk_index, lane_index);

        if (RUNTIME_MESH)
            primitive_output_offset += MESHLET_PAYLOAD_PRIMITIVES_PER_CHUNK * chunk_index;
        else
            primitive_output_offset += chunk_info.primitive_offset;

        if (!RUNTIME_MESH)
            indices += chunk_info.vertex_offset;

        if (UNROLLED_MESH)
            output_indices32.data[primitive_output_offset + lane_index] = indices + meta.base_vertex_offset;
        else
            output_indices8.data[primitive_output_offset + lane_index] = u8vec3(indices);
    }
    else if (RUNTIME_MESH)
    {
        output_indices8.data[primitive_output_offset + MESHLET_PAYLOAD_PRIMITIVES_PER_CHUNK * chunk_index + lane_index] = u8vec3(0);
    }

    // Attributes
    if (chunk_index < meta.num_chunks && lane_index < chunk_info.vertex_count)
    {
        int exponent;
        i16vec3 pos = meshlet_decode_snorm_scaled_i16x3(
                meshlet_index * NUM_U32_STREAMS + MESHLET_STREAM_TYPE_POSITION,
                chunk_index, lane_index, exponent);

        vec3 fp_pos = ldexp(vec3(pos), ivec3(exponent));
        uint vertex_output_offset;
        if (RUNTIME_MESH)
        {
            vertex_output_offset = gl_WorkGroupSize.x * meshlet_index +
                    MESHLET_PAYLOAD_VERTICES_PER_CHUNK * chunk_index +
                    registers.vertex_offset;
        }
        else
            vertex_output_offset = registers.vertex_offset + meta.base_vertex_offset + chunk_info.vertex_offset;
        output_stream_pos.data[vertex_output_offset + lane_index] = fp_pos;

        if (TARGET_MESH_STYLE >= MESH_STYLE_TEXTURED)
        {
            bool t_sign;
            u8vec4 nt = meshlet_decode_normal_tangent_oct8(
                meshlet_index * NUM_U32_STREAMS + MESHLET_STREAM_TYPE_NORMAL_TANGENT_OCT8,
                chunk_index, lane_index, t_sign);
            i16vec2 uv = meshlet_decode_snorm_scaled_i16x2(
                meshlet_index * NUM_U32_STREAMS + MESHLET_STREAM_TYPE_UV,
                chunk_index, lane_index, exponent);
            vec2 fp_uv = attribute_decode_snorm_exp_uv(uv, exponent);

            mediump mat2x4 NT = attribute_decode_oct8_normal_tangent(nt, t_sign);
            output_stream_textured_attr.data[vertex_output_offset + lane_index] =
                TexturedAttr(pack_a2bgr10(NT[0]), pack_a2bgr10(NT[1]), fp_uv);
        }
    }
    else if (RUNTIME_MESH)
    {
        output_stream_pos.data[gl_WorkGroupSize.x * meshlet_index +
                MESHLET_PAYLOAD_VERTICES_PER_CHUNK * chunk_index +
                registers.vertex_offset + lane_index] = vec3(intBitsToFloat(-1));

        if (TARGET_MESH_STYLE >= MESH_STYLE_TEXTURED)
        {
            output_stream_textured_attr.data[gl_WorkGroupSize.x * meshlet_index +
                    MESHLET_PAYLOAD_VERTICES_PER_CHUNK * chunk_index +
                    registers.vertex_offset + lane_index] = TexturedAttr(-1u, -1u, vec2(intBitsToFloat(-1)));
        }
    }
}
