#version 450
#extension GL_EXT_mesh_shader : require

#pragma optimize off

out gl_MeshPerVertexEXT
{
    invariant vec4 gl_Position;
} gl_MeshVerticesEXT[];

#extension GL_KHR_shader_subgroup_basic : require

#if defined(MESHLET_PRIMITIVE_CULL_WAVE32_DUAL) && MESHLET_PRIMITIVE_CULL_WAVE32_DUAL
#define NV_STYLE
#endif

#ifdef NV_STYLE
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#endif

#ifndef MESHLET_SIZE
#error "Must define MESHLET_SIZE"
#endif

layout(max_primitives = MESHLET_SIZE, max_vertices = MESHLET_SIZE / 2, triangles) out;
layout(local_size_x_id = 0) in;

#include "meshlet_payload_constants.h"

#define MESHLET_PAYLOAD_DESCRIPTOR_SET 0
#define MESHLET_PAYLOAD_META_BINDING 0
#define MESHLET_PAYLOAD_STREAM_BINDING 1
#define MESHLET_PAYLOAD_PAYLOAD_BINDING 2
#include "meshlet_payload_decode.h"
#include "meshlet_attribute_decode.h"
#include "meshlet_render_types.h"

#include "meshlet_primitive_cull.h"

layout(location = 0) out vec3 vNormal[];
layout(location = 1) out vec4 vTangent[];
layout(location = 2) out vec2 vUV[];
layout(location = 3) perprimitiveEXT out uint vDrawID[];

layout(set = 1, binding = 0) uniform UBO
{
    mat4 VP;
};

layout(set = 1, binding = 2) uniform UBOViewport
{
    vec4 viewport;
};

#ifdef MESHLET_RENDER_TASK_HIERARCHICAL
taskPayloadSharedEXT CompactedDrawInfoPayload mesh_payload;
#else
layout(set = 0, binding = 4, std430) readonly buffer CompactedDraws
{
    CompactedDrawInfo infos[];
} mesh_payload;
#endif

layout(set = 0, binding = 5, std430) readonly buffer Transforms
{
    mat4 data[];
} transforms;

layout(set = 0, binding = 10) buffer Stats
{
    uint invocations;
    uint prim;
    uint vert;
} stats;

void main()
{
    uint linear_index = gl_LocalInvocationIndex;
    uint compacted_meshlet_index = meshlet_get_meshlet_index();
    uint base_chunk_index = meshlet_get_base_chunk_index();

#if defined(MESHLET_RENDER_TASK_HIERARCHICAL) && !MESHLET_RENDER_TASK_HIERARCHICAL
    CompactedDrawInfo task = mesh_payload.info;
    task.meshlet_index += uint(mesh_payload.offsets[compacted_meshlet_index]);
#else
    CompactedDrawInfo task = mesh_payload.infos[compacted_meshlet_index];
#endif

    MeshletMetaRuntime meta = meshlet_metas_runtime.data[task.meshlet_index];
    mat4 M = transforms.data[task.node_offset];

    int lane_index;
    uint chunk_index;

#ifdef NV_STYLE
    // NV mode
    chunk_index = 0;
    lane_index = int(gl_SubgroupInvocationID);
#else
    if (gl_SubgroupSize == 64)
    {
        chunk_index = gl_SubgroupID;
        lane_index = int(gl_SubgroupInvocationID);
        meshlet_setup_local_invocation(
                gl_SubgroupID * gl_SubgroupSize + gl_SubgroupInvocationID,
                lane_index, chunk_index);
    }
    else if (gl_SubgroupSize == 32)
    {
        chunk_index = gl_SubgroupID / 2;
        lane_index = int(gl_SubgroupInvocationID) + int(gl_SubgroupID & 1) * 32;
        meshlet_setup_local_invocation(
                gl_SubgroupID * gl_SubgroupSize + gl_SubgroupInvocationID,
                lane_index, chunk_index);
    }
    else
    {
        chunk_index = gl_LocalInvocationIndex / 64u;
        lane_index = int(gl_LocalInvocationIndex & 63u);
        meshlet_setup_local_invocation(gl_LocalInvocationIndex, lane_index, chunk_index);
    }
#endif

    chunk_index += base_chunk_index;

    MeshletChunkInfo index_chunk_info = meshlet_get_chunk_info(meta.stream_offset, chunk_index);
    uvec3 decoded_index_buffer = uvec3(0);
#ifdef NV_STYLE
    uvec3 decoded_index_buffer_hi = uvec3(0);
#endif
    vec3 world_pos;
    vec4 clip_pos = vec4(-1.0);

    if (chunk_index < meta.num_chunks)
    {
        if (lane_index < index_chunk_info.primitive_count)
            decoded_index_buffer = meshlet_decode_index_buffer(meta.stream_offset, chunk_index, lane_index);
#ifdef NV_STYLE
        if (32 + lane_index < index_chunk_info.primitive_count)
            decoded_index_buffer_hi = meshlet_decode_index_buffer(meta.stream_offset, chunk_index, 32 + lane_index);
#endif

        if (lane_index < index_chunk_info.vertex_count)
        {
            int exponent;
            i16vec3 ipos = meshlet_decode_snorm_scaled_i16x3(
                meta.stream_offset + MESHLET_STREAM_TYPE_POSITION,
                chunk_index, lane_index, exponent);
            vec3 pos = ldexp(vec3(ipos), ivec3(exponent));
            world_pos = (M * vec4(pos, 1.0)).xyz;
            clip_pos = VP * vec4(world_pos, 1.0);
        }
    }

#ifdef NV_STYLE
    meshlet_emit_primitive_dual(decoded_index_buffer, decoded_index_buffer_hi, clip_pos, viewport);
#else
    meshlet_emit_primitive(decoded_index_buffer, clip_pos, viewport);
#endif

    if (meshlet_lane_has_active_vert())
    {
        uint out_vert_index = meshlet_compacted_vertex_output();

        int exponent;
        bool t_sign;
        u8vec4 nt = meshlet_decode_normal_tangent_oct8(
                meta.stream_offset + MESHLET_STREAM_TYPE_NORMAL_TANGENT_OCT8,
                chunk_index, lane_index, t_sign);
        i16vec2 uv = meshlet_decode_snorm_scaled_i16x2(
                meta.stream_offset + MESHLET_STREAM_TYPE_UV,
                chunk_index, lane_index, exponent);

        gl_MeshVerticesEXT[out_vert_index].gl_Position = clip_pos;
        vUV[out_vert_index] = attribute_decode_snorm_exp_uv(uv, exponent);
        mediump mat2x4 NT = attribute_decode_oct8_normal_tangent(nt, t_sign);
        vNormal[out_vert_index] = mat3(M) * NT[0].xyz;
        vTangent[out_vert_index] = vec4(mat3(M) * NT[1].xyz, NT[1].w);
    }

    if (gl_LocalInvocationIndex < shared_active_prim_count_total)
        vDrawID[gl_LocalInvocationIndex] = task.meshlet_index;
#ifdef NV_STYLE
    if (gl_LocalInvocationIndex + 32u < shared_active_prim_count_total)
        vDrawID[gl_LocalInvocationIndex + 32u] = task.meshlet_index;
#endif

#if 0
    if (gl_LocalInvocationIndex == 0)
    {
        atomicAdd(stats.invocations, gl_WorkGroupSize.x * gl_WorkGroupSize.y);
        atomicAdd(stats.prim, shared_active_prim_count_total);
        atomicAdd(stats.vert, shared_active_vert_count_total);
    }
#endif
}
