#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_scalar_block_layout : require

#extension GL_KHR_shader_subgroup_basic : require

#if defined(MESHLET_PRIMITIVE_CULL_WAVE32_DUAL) && MESHLET_PRIMITIVE_CULL_WAVE32_DUAL
#define NV_STYLE
#endif

#ifdef NV_STYLE
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#endif

#ifndef MESHLET_SIZE
#error "Must define MESHLET_SIZE"
#endif

#if MESHLET_SIZE > 64 && !MESHLET_VERTEX_ID
shared uint shared_attr_index[MESHLET_SIZE / 2];
#endif

layout(max_primitives = MESHLET_SIZE, max_vertices = MESHLET_SIZE / 2, triangles) out;
layout(local_size_x_id = 0) in;

#include "meshlet_render_types.h"
#include "meshlet_primitive_cull.h"

#if MESHLET_VERTEX_ID
layout(location = 0) flat out uint vVertexID[];
layout(location = 1) perprimitiveEXT out uint vTransformIndex[];
layout(location = 2) perprimitiveEXT out uint vDrawID[];
#else
layout(location = 0) out mediump vec3 vNormal[];
layout(location = 1) out mediump vec4 vTangent[];
layout(location = 2) out vec2 vUV[];
layout(location = 3) perprimitiveEXT out uint vDrawID[];
#endif

layout(set = 1, binding = 0) uniform UBO
{
    mat4 VP;
};

layout(set = 1, binding = 2) uniform UBOViewport
{
    vec4 viewport;
};

layout(set = 0, binding = 0, scalar) readonly buffer IBO
{
    u8vec3 data[];
} ibo;

layout(set = 0, binding = 1, scalar) readonly buffer VBOPOS
{
    vec3 data[];
} pos;

struct TexturedAttr
{
    uint n;
    uint t;
    vec2 uv;
};

layout(set = 0, binding = 2, std430) readonly buffer VBOATTR
{
    TexturedAttr data[];
} attr;

layout(set = 0, binding = 3, std430) readonly buffer IndirectCommands
{
    IndirectDrawMesh draws[];
} indirect_commands_mesh;

#ifdef MESHLET_RENDER_TASK_HIERARCHICAL
taskPayloadSharedEXT CompactedDrawInfoPayload mesh_payload;
#else
layout(set = 0, binding = 4, std430) readonly buffer CompactedDraws
{
    CompactedDrawInfo infos[];
} mesh_payload;
#endif

layout(set = 0, binding = 5, std430) readonly buffer Transforms
{
    mat4 data[];
} transforms;

layout(set = 0, binding = 10) buffer Stats
{
    uint invocations;
    uint prim;
    uint vert;
} stats;

mediump vec4 unpack_bgr10a2(uint v)
{
    mediump ivec4 vs;
    vs.x = bitfieldExtract(int(v), 0, 10);
    vs.y = bitfieldExtract(int(v), 10, 10);
    vs.z = bitfieldExtract(int(v), 20, 10);
    vs.w = bitfieldExtract(int(v), 30, 3);
    return vec4(vs) / vec4(511.0, 511.0, 511.0, 1.0);
}

void main()
{
    uint compacted_meshlet_index = meshlet_get_meshlet_index();
    uint base_chunk_index = meshlet_get_base_chunk_index();

#if defined(MESHLET_RENDER_TASK_HIERARCHICAL) && !MESHLET_RENDER_TASK_HIERARCHICAL
    CompactedDrawInfo task = mesh_payload.info;
    task.meshlet_index += uint(mesh_payload.offsets[compacted_meshlet_index]);
#else
    CompactedDrawInfo task = mesh_payload.infos[compacted_meshlet_index];
#endif

#ifdef NV_STYLE
    uint linear_index = gl_SubgroupInvocationID;
#else
    uint linear_index = gl_LocalInvocationIndex;
    uint lane_index = gl_LocalInvocationIndex & 63u;
    uint chunk_id = gl_LocalInvocationIndex / 64u;
    meshlet_setup_local_invocation(gl_LocalInvocationIndex, lane_index, chunk_id);
#endif

    IndirectDrawMesh meshlet = indirect_commands_mesh.draws[task.meshlet_index];
    mat4 M = transforms.data[task.node_offset];

    // Transform positions.
    vec3 world_pos;
    vec4 clip_pos;

#ifdef NV_STYLE
    uint vert_id = meshlet.vertex_offset + linear_index + 32u * base_chunk_index;
    const bool vbo_in_range = true;
#else
    uint vert_id = meshlet.vertex_offset + 32u * (chunk_id + base_chunk_index) + lane_index;
    bool vbo_in_range = lane_index < 32u;
#endif

    if (vbo_in_range)
    {
        vec3 pos = pos.data[vert_id];
        world_pos = (M * vec4(pos, 1.0)).xyz;
        clip_pos = VP * vec4(world_pos, 1.0);
    }

#ifdef NV_STYLE
    uvec3 prim_lo = uvec3(ibo.data[meshlet.primitive_offset + linear_index + 64u * base_chunk_index]);
    uvec3 prim_hi = uvec3(ibo.data[meshlet.primitive_offset + linear_index + 64u * base_chunk_index + 32]);
    meshlet_emit_primitive_dual(prim_lo, prim_hi, clip_pos, viewport);
#else
    uvec3 prim = uvec3(ibo.data[meshlet.primitive_offset + linear_index + 64u * base_chunk_index]);
    meshlet_emit_primitive(prim, clip_pos, viewport);
#endif

    if (meshlet_lane_has_active_vert())
    {
        uint out_vert_index = meshlet_compacted_vertex_output();
        gl_MeshVerticesEXT[out_vert_index].gl_Position = clip_pos;

#if MESHLET_VERTEX_ID
        vVertexID[out_vert_index] = vert_id;
#elif MESHLET_SIZE > 64
        shared_attr_index[out_vert_index] = vert_id;
#else
        TexturedAttr a = attr.data[vert_id];
        mediump vec3 n = unpack_bgr10a2(a.n).xyz;
        mediump vec4 t = unpack_bgr10a2(a.t);
        vUV[out_vert_index] = a.uv;
        vNormal[out_vert_index] = mat3(M) * n;
        vTangent[out_vert_index] = vec4(mat3(M) * t.xyz, t.w);
#endif
    }

#if MESHLET_SIZE > 64 && !MESHLET_VERTEX_ID
    barrier();

    if (gl_LocalInvocationIndex < shared_active_vert_count_total)
    {
        TexturedAttr a = attr.data[shared_attr_index[gl_LocalInvocationIndex]];
        mediump vec3 n = unpack_bgr10a2(a.n).xyz;
        mediump vec4 t = unpack_bgr10a2(a.t);
        vUV[gl_LocalInvocationIndex] = a.uv;
        vNormal[gl_LocalInvocationIndex] = mat3(M) * n;
        vTangent[gl_LocalInvocationIndex] = vec4(mat3(M) * t.xyz, t.w);
    }
#endif

    if (gl_LocalInvocationIndex < shared_active_prim_count_total)
    {
#if MESHLET_VERTEX_ID
        vTransformIndex[gl_LocalInvocationIndex] = task.node_offset;
#endif
        vDrawID[gl_LocalInvocationIndex] = task.meshlet_index;
    }

#ifdef NV_STYLE
    if (gl_LocalInvocationIndex + 32 < shared_active_prim_count_total)
    {
        vDrawID[gl_LocalInvocationIndex + 32] = task.meshlet_index;
#if MESHLET_VERTEX_ID
        vTransformIndex[gl_LocalInvocationIndex + 32] = task.node_offset;
#endif
    }
#endif

#if 0
    if (gl_LocalInvocationIndex == 0)
    {
        atomicAdd(stats.invocations, gl_WorkGroupSize.x * gl_WorkGroupSize.y);
        atomicAdd(stats.prim, shared_active_prim_count_total);
        atomicAdd(stats.vert, shared_active_vert_count_total);
    }
#endif
}
